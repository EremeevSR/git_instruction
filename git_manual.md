# **Git** - инструкция
## 1 Инициализация **Git**
 Для создания создания нового репозитория или загрузки уже существующего используется команда __*git init*__

 Пример использования команды:

 ![git_init](git_init.bmp)

 Как видно из рисунка, при вводе команды был реинициализирован уже существующий репозиторий.

## 2 Состояние/статус репозитория
 Для проверки текущего состояния репозитория используется команда __*git status*__.

 Результат её работы можно видеть на примере обращения к пустому/зафиксированному репозиторию:

  ![git_status_clear](git_status_clear.bmp)

  В случае, если в репозиторий будет добавлен новый файл, то вывод будет иным:

  ![git_status_file_added](git_status_file_added.bmp)

  Из рисунка выше видно, что в репозитории лежит вновь созданный файл "__*.gitignore*__"

## 3 Добавление файлов в систему контроля версий
  Если вызвать команду __*git status*__ применительно к папке, в которой был создан некоторый файл, то **Git** сам подскажет, что нужно сделать, чтобы новый файл начал отслеживаться и мог быть зафиксирован на каком-то этапе своего существования.

  ![git_status_file_added](git_status_file_added.bmp)

  Из данного вызова команды __*git status*__ видно, что для того, чтобы файл отслеживался системой контроля версий, к нему нужно применить команду __*git add*__, указав при этом имя и расширение файла. Эта команда идет рука об руку с другой командой - __*git commit*__, которая фиксирует текущее состояние файла. При её вызове рекомендуется использовать ещё два аргумента командной строки, а именно: __*-m*__ и __"Строка с комментарием"__. Это позволяет при отслеживании состояния файлов понять, что с ними происходило от версии к версии.

## 4 Журнал изменений
  Для отображения истории изменения файлов в репозитории применяется команда __*git log*__.

  ![git_log](git_log.bmp)

  В результате вызова будет выведен список версий, каждая из которых будет иметь свое уникальное название (_выделено желтым_), будет содержать информацию об авторе, дате изменения и сопроводительный комментарий.

## 5 Переключение между версиями файлов
  Для переключения между различными версиями файла используется комманда __*git checkout*__, после которой указывается имя версии файла (нужно указать по меньшей мере 4 символа):

  ![git_checkout_commit](git_checkout_commit.bmp)

  Теперь при вызове журнала изменений выбранная версия будет текущей:

  ![git_log_after_checkout_to_commit](git_log_after_checkout_to_commit.bmp)

  Для возврата к последней версии файла текущей ветви нужно после команды __*git checkout*__ указать название ветви:

  ![git_checkout_from_commit_to_branch](git_checkout_from_commit_to_branch.bmp)
  
## 6 Сравнение версий файла
  Для просмотра отличий между версиями файлов используется команда __*git diff*__, в качестве аргументов могут указываться конкретные версии файла:

  ![git_diff_between_commits](git_diff_between_commits.bmp)

  Без аргументов данная команда выведет разницу между текущей и предыдущей версиями файла.

## 7 Ветвление
При работе со сложными проектами нередко возникает необходимость разделять задачи. Причем может сложиться ситуация, подразумевающая параллельную работу над одним файлом/проектом нескольких пользователей. Для того, чтобы не возникала путанница и был сквозной контроль итогового файла используется ветвление.

Для создания отдельной ветви используется команда __*git branch*__ *имя_ветви*:

![git_branch.bmp](git_branch.bmp)

Без аргументов данная команда выводит список существующих ветвей, что также видно на рисунке выше.

Для визуализации изменений в виде дерева, состоящего из существующих ветвей, можно вызвать команду __*git log*__ с параметром _--graph_:

![git_log_tree](git_log_tree.bmp)

На рисунке видно, что после одной из версий изменения файла шли по отдельной ветви, которая затем вливается в основную. Это результат операции слияния ветвей, которое выполняется командой __*git merge*__ *branch_name*:

![git_merge](git_merge.bmp)

Из рисунка видно, что иногда при слиянии ветвей могут возникать конфликты, которые нужно разрешить, а затем зафиксировать, чтобы слияние было выполнено на все 100%.

После слияния, неиспользуемые ветви можно удалить, для этого к команде __*git branch*__ добавляется суффикс _-d_ и имя удаляемой ветви:

![git_delete_branch](git_delete_branch.bmp)

___
### На текущий момент конечный результат работы выглядит так: 

![git_all_of_commits](git_all_of_commits.bmp)

___
