# Основные синтаксические правила языка разметки Markdown
## 1 Заголовки и разделы в Markdown
Чтобы добавить заголовок первого, второго или n-ого уровня, перед соответствующим
предложением или словосочетанием необходимо добавить знак решетки "#" в количестве,
определяющем уровень заголовка, например:

# Заголовок первого уровня, один знак "#"
## Заголовок второго уровня, два знака "#"
### Заголовок третьего уровня, три знака "#"
#### И так далее...

Альтернативой решеткам при выделении заголовков первого и второго уровня могут служить
тройные знаки равно и дефисы, добавляемые под текстом заголовка:

Заголовок первого уровня с тремя "="
===
Заголовок второго уровня с тремя "-"
---
Также блоки текста (разделы) в Markdown могут быть разделены посредством применения трех подчеркиваний или звездочек:

Три подчеркивания:
___
Три звездочки:
***
## 2 Выделение текста
Текст в языке разметки Markdown может выделяться курсивом, полужирным начертанием, и перечеркиванием.
Для выделения слов курсивом необходимо обрамить слова одинарными звездочками "*" или нижними подчеркиваниями "_":

*Курсив со звездочками*

_Курсив с подчеркиваниями_

Для выделения слов полужирным используются двойные звездочки "**" и подчеркивания "__", которыми также нужно обрамить выделяемые слова:

**Полужирный текст с двойными звездочками**

__Полужирный текст с двойным подчеркиванием__

Если по ходу текста нужно что-то перечеркнуть, то это делается с помощью обрамления двойной тильдой "~~":

~~Перечеркнутый текст~~

## 3 Списки
Ненумерованные списки в Markdown могут быть созданы либо с помощью звездочки "*", либо с помощью дефиса "-":

* Элемент списка со звездочкой "*"
- Элемент списка с дефисом "-"

Важно не забывать делать отступ от соответствующего знака!
Уровень элементов списка определяется табуляцией (отступами относительно элементов предыдущего уровня):

* Элемент уровня 1
	* Элемент уровня 2
		* Элемент уровня 3
			* И т.д.

Нумерованные списки создаются с помощью сочетания число/точка "1.":

1. Первый элемент первого уровня нумерованного списка
3. Второй элемент первого уровня нумерованного списка
	1. Первый элемент второго уровня нумерованного списка
	1. Второй элемент второго уровня нумерованного списка

Можно заметить, что элементы одного уровня одного списка нумеруются по-порядку вне зависимости от того, какое
число стоит перед знаком точки.

## 4 Встраиваемый контент
В качестве встраиваемого контента рассматриваются ссылки, изображения, код и блоки кода.

Чтобы указать ссылку, нужно указать её название в квадратных скобках, а в круглых скобках, следующих за квадратными, указать адрес ссылки, по которому она перенаправляет нажавшего на неё:

[Ссылка на локальный файл](B:\Sergey_415\Learning_GB\Introduction_in_version_control\Seminars\git_learning\picture.bmp);
[Ссылка на интернет-ресурс](https://google.com)

Есть и альтернативный способ, в котором используются только квадратные скобки:

[Ссылка на локальный файл][1]; [Ссылка на интернет-ресурс][2]

[1]: B:\Sergey_415\Learning_GB\Introduction_in_version_control\Seminars\git_learning\picture.bmp
[2]: https://google.com

Изображения вставляются схожим образом, только перед всей конструкцией нужно добавить восклицательный знак:

![Картинка](picture.bmp)

Встраиваемый код выделяется обратными кавычками `printf("Hello world!")`, находятся где буква "ё".

Для выделения блока кода используется табуляция:

	int main(){
		printf("Hello world!");
		return 0;
	}

или обратные кавычки:
```C
int main(){
	printf("Hello world!");
	return 0;
}
```
Для цитирования используется угловая скобка:
> Цитата
>> Цитата в цитате

В Markdown можно использовать таблицы:

|Column 1| Column 2|
|:--------:|:---------:|
|Row 1|Empty field 1|
|Row 2|Empty field 2|

Двоеточие указывает на выравнивание в ячейках.
___
### На этом основные синтаксические правила Markdown можно считать законченными.
___

# **Git** - инструкция
## 1 Инициализация **Git**
 Для создания создания нового репозитория или загрузки уже существующего используется команда __*git init*__

 Пример использования команды:

 ![git_init](git_init.bmp)

 Как видно из рисунка, при вводе команды был реинициализирован уже существующий репозиторий.

## 2 Состояние/статус репозитория
 Для проверки текущего состояния репозитория используется команда __*git status*__.

 Результат её работы можно видеть на примере обращения к пустому/зафиксированному репозиторию:

  ![git_status_clear](git_status_clear.bmp)

  В случае, если в репозиторий будет добавлен новый файл, то вывод будет иным:

  ![git_status_file_added](git_status_file_added.bmp)

  Из рисунка выше видно, что в репозитории лежит вновь созданный файл "__*.gitignore*__"

## 3 Добавление файлов в систему контроля версий
  Если вызвать команду __*git status*__ применительно к папке, в которой был создан некоторый файл, то **Git** сам подскажет, что нужно сделать, чтобы новый файл начал отслеживаться и мог быть зафиксирован на каком-то этапе своего существования.

  ![git_status_file_added](git_status_file_added.bmp)

  Из данного вызова команды __*git status*__ видно, что для того, чтобы файл отслеживался системой контроля версий, к нему нужно применить команду __*git add*__, указав при этом имя и расширение файла. Эта команда идет рука об руку с другой командой - __*git commit*__, которая фиксирует текущее состояние файла. При её вызове рекомендуется использовать ещё два аргумента командной строки, а именно: __*-m*__ и __"Строка с комментарием"__. Это позволяет при отслеживании состояния файлов понять, что с ними происходило от версии к версии.

## 4 Журнал изменений
  Для отображения истории изменения файлов в репозитории применяется команда __*git log*__.

  ![git_log](git_log.bmp)

  В результате вызова будет выведен список версий, каждая из которых будет иметь свое уникальное название (_выделено желтым_), будет содержать информацию об авторе, дате изменения и сопроводительный комментарий.

## 5 Переключение между версиями файлов
  Для переключения между различными версиями файла используется комманда __*git checkout*__, после которой указывается имя версии файла (нужно указать по меньшей мере 4 символа):

  ![git_checkout_commit](git_checkout_commit.bmp)

  Теперь при вызове журнала изменений выбранная версия будет текущей:

  ![git_log_after_checkout_to_commit](git_log_after_checkout_to_commit.bmp)

  Для возврата к последней версии файла текущей ветви нужно после команды __*git checkout*__ указать название ветви:

  ![git_checkout_from_commit_to_branch](git_checkout_from_commit_to_branch.bmp)
  
## 6 Сравнение версий файла
  Для просмотра отличий между версиями файлов используется команда __*git diff*__, в качестве аргументов могут указываться конкретные версии файла:

  ![git_diff_between_commits](git_diff_between_commits.bmp)

  Без аргументов данная команда выведет разницу между текущей и предыдущей версиями файла.

## 7 Ветвление
При работе со сложными проектами нередко возникает необходимость разделять задачи. Причем может сложиться ситуация, подразумевающая параллельную работу над одним файлом/проектом нескольких пользователей. Для того, чтобы не возникала путанница и был сквозной контроль итогового файла используется ветвление.

Для создания отдельной ветви используется команда __*git branch*__ *имя_ветви*:

![git_branch.bmp](git_branch.bmp)

Без аргументов данная команда выводит список существующих ветвей, что также видно на рисунке выше.

Для визуализации изменений в виде дерева, состоящего из существующих ветвей, можно вызвать команду __*git log*__ с параметром _--graph_:

![git_log_tree](git_log_tree.bmp)

На рисунке видно, что после одной из версий изменения файла шли по отдельной ветви, которая затем вливается в основную. Это результат операции слияния ветвей, которое выполняется командой __*git merge*__ *branch_name*:

![git_merge](git_merge.bmp)

Из рисунка видно, что иногда при слиянии ветвей могут возникать конфликты, которые нужно разрешить, а затем зафиксировать, чтобы слияние было выполнено на все 100%.

После слияния, неиспользуемые ветви можно удалить, для этого к команде __*git branch*__ добавляется суффикс _-d_ и имя удаляемой ветви:

![git_delete_branch](git_delete_branch.bmp)

___
### На текущий момент конечный результат работы выглядит так: 

![git_all_of_commits](git_all_of_commits.bmp)

___